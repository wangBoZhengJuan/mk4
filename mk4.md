# 筛法生成器源码运行逻辑

### 我理解的老师的mk4.py里的筛法生成器源码运行逻辑 

先把源码引入：
```python
def primes():
    D = {}
    q = 2
    while True:
        if q not in D:
            yield q
            D[q*q] = [q]
        else:
            for p in D[q]:
                D.setdefault(p+q, []).append(p)
            del D[q]
        q += 1
```
生成器primes()
首先创建变量D和q，然后无限循环while True，由于D为空dict，所以`if q not in D`判断为True(意味着`else`后面的代码不被执行)，于是`yield q`，`q=2`，然后挂起，等待接收‘下一个’命令，一旦next命令下达，则从`D[q*q] = [q]`此行代码开始执行，得到`D[4] = [2]`（即`D = {4:[2]}`）,紧接着执行`q += 1`, 得到`q=3`，然后进行下一轮循环，由于`q=3`不在D里面，因此if判断为True，`yield q`，得到`q=3`，挂起等待下一个命令，一旦next命令下达，则得到`D[9] = [3]`（即`D = {4:[2],9:[3]}`），继续向下执行`q += 1`，得到`q=4`，又开始进行下一轮循环，注意这一轮if判断为False，因为`q=4`是字典D里面的key，所以运行else语句，（*D[q]中的q是4，D[q]对应的value是p，为[2]*），执行`D.setdefault(p+q, []).append(p)`，（*注意：字典的setdefault()方法，此方法传入的参数是一key,value对，当字典调用此方法时返回的是key对应的value*），得到`D = {4:[2],9:[3],6:[2]}`，由于此时，字典D里就只有一对q是key的配对，所以for循环执行一次就跳出，然后执行`del D[q]`，得到`D = {9:[3],6:[2]}`,`4:[2]`被删掉了。然后执行`q += 1`，得到`q=5`，进入下一轮循环，if判断成功，`yield q`,得到`q=5`，挂起，接到next命令执行`D[q*q] = [q]`，得到`D = {9:[3],6:[2],25:[5]}`，执行`q += 1`，得到`q=6`，进入下一轮循环，if判断失败，运行else语句，得到`D = {9:[3],6:[2],25:[5],8:[2]}`，for循环一次跳出，执行`del D[q]`，得到`D = {9:[3],25:[5],8:[2]}`，向下执行`q += 1`,得到`q=7`，进入下一轮循环，if判断成功，`yield q`，得到`q=7`，挂起，接到next命令执行`D[q*q] = [q]`，得到`D = {9:[3],25:[5],8:[2],49:[7]}`，向下执行`q += 1`，得到`q=8`，进入下一轮循环，if判断失败，运行else，得到`D = {9:[3],25:[5],49:[7]，10:[2]}`，向下执行`q += 1`，得到`q=9`......如此循环下去，会发现字典D里面的value始终是我们要的质数。

> 说实话，看懂了之后，会明白这个生成器算法写的真的很高明。我花了将近3个夜晚才理清。之所以花了这么长时间，是因为自己的思维定式绑住了自己，比如我老是会不自觉地把q当成质数。还有就是，归根结底还是对程序的结构和运行流程不是很熟练。
>
> -郑娟


诚挚邀请老师和同学指正。

